https://tkssharma.com/getting-started-with-nest-js-framework-for-nodejs-apis/
https://docs.nestjs.com/

package.json 
nest new nest-rest-api

/* generate a controller called items */ 
nest g controller items 


/* watch the server and update changes => usse ndoemon to constanly watch the server and update it  */
npm run start:dev

/*  "get the Hello wolrd!"  default behaviour */
localhost:3000 

localhost:3000/items  {"statusCode":404,"message":"Cannot GET /items","error":"Not Found"}


to create an endpoint we use decorator 



curl -X POST http://localhost:3000/items -H "Content-Type: application/json" --data '{ "name" : "Item One" , "qty" : 100 , "description" : "This is item one" }'
curl -X PUT http://localhost:3000/items/3  -H "Content-Type: application/json" --data '{ "name" : "Item One" , "qty" : 100 , "description" : "This is item one" }'




- to deal withd atabase we need a service
- generate a service 
nest g service items


@Injectable() ????????



npm i -g @nestjs/cli =? gives u the command line interface to be able to generate modules ad services

npm i @nestjs/typeorm typeorm pg @nestjs/config

in .env : list environement variables for the postgres database

use typeorm  : object relational mapper , basically conencts database through entities


prisma
https://progressivecoder.com/build-a-nestjs-prisma-rest-api/



https://www.youtube.com/watch?v=GHTA143_b-s
for nest modules are very important : app.module.ts is a global file
app.module.ts is the main module of the app that will import other modules


https://docs.nestjs.com/modules
Modules
A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata 
that Nest makes use  of to organize the application structure

decorator is a  function that add some metadata to the current class or function 

a module can import other modules (Application Module can import USER/ORDERS/CHAT/.. Modules)
every mODULE CAN import controllers and providers


usually we orgonize modules into feature modules , so if we have an application , where we have bookmarks,
authentication logic , login , sign up , user module ( that handles logic related to the user) , database module
==? breaking down you app into modules


Modules in nestjs organizie  your app


authentication mODULE


launch our application --> bootstrap logic is inside main.ts


generate a module with nest   == > nest g module user | nest g module bookmark

when we build a nestjs application : we separate our logic into controllers and service  
Controllers
Controllers are responsible for handling incoming requests and returning responses to the client.

Providers || services
responsible for executing the business logic




@Injectable({}) means it's going to be able to use the dependency injection that NestJs uses under the hood 

what are dependency injection :
    we have authService class
    we have AuthControlelr class
    usually the controller need to class AuthService class
    Controller will receive the request from the internet ( post request asking to login a user) 
    Controller will call a function from AuthService and return it's result back to the client back to the browser

    ===> to do that AuthController have to instanciate a AuthService class
    inside controller  const service = new AuthService()
    => to avoid doing that  : manage where it's created , and who manages it all we usee "dependency injection"
    => instead of our controller to actually do 

        import { Controller } from "@nestjs/common";
        import { AuthService } from "./auth.service";

        @Controller()
        export class AuthController {
            constructor() {
                const service = new AuthService();
            }
        }

        it will do  :

        import { Controller } from "@nestjs/common";
        import { AuthService } from "./auth.service";

        @Controller()
        export class AuthController {
            /* we dont need to wowrry about instanciation of AuthService and how to pass it to the controller file  
                nestjs will handle on itself , how to instanciate the authService , and how to pass it to you in that AuthCiontrolelr
            */
            constructor(private authService: AuthService) {
               
            }
        }


    dependency injection allows us to do not handle dependency management





